# Direct Implementation Workflow
# Simple plan-implement-verify workflow when research is not needed

[workflow]
name = "direct-implementation"
description = "Simple plan-implement-verify workflow for familiar code changes"

[[phases]]
id = "plan"
requires_user_input = true
required_artifacts = ["implementation-plan", "verification-plan"]
prompt = """
# Plan Phase

Create an implementation plan directly. This workflow assumes you already understand the codebase and requirements.

## Tasks

1. Break down the work into atomic, testable tasks
2. Identify file dependencies and task ordering
3. Consider which tasks can run in parallel

## Outputs

### implementation-plan.md
- Task breakdown (descriptions, dependencies, steps)
- Parallelization strategy
- Any assumptions being made

### verification-plan.md
Create a verification plan based on what's available in the project:

```markdown
# Verification Plan

## Automated Checks
List specific commands to run:
- [ ] `<command>` - <what it verifies>

## Acceptance Criteria
What must be true for implementation to be complete?
```
"""
suggested_next = ["implement", "plan"]

[[phases]]
id = "implement"
use_tasks = true
on_blocked = "self"
max_retries = 3
context_artifacts = ["implementation-plan"]
required_json_artifacts = ["proposals", "challenges"]
prompt = """
# Implement Phase

Execute the implementation plan (injected above).

## Setup
1. Create tasks.json in this phase directory based on the plan
2. All tasks start with `status: "todo"`

## Task Execution
1. Work through tasks in dependency order
2. Set each task to in-progress before starting
3. Mark tasks done immediately after completion
4. Log progress for each significant step

## Guidelines
- Make minimal, focused changes
- Don't over-engineer or add unnecessary features
- Test changes as you go
"""
suggested_next = ["verify"]

[[phases]]
id = "verify"
context_artifacts = ["verification-plan"]
prompt = """
# Verify Phase

Verify the implementation meets requirements using the verification plan (injected above).

## Execution

### 1. Run Automated Checks
Execute each command from the verification plan's "Automated Checks" section.

### 2. Check Acceptance Criteria
Verify each criterion from the verification plan is met.

## Outcomes

**All checks pass:** Transition to complete.

**Checks fail:**
- If fixable: Fix and re-run checks
- If needs significant work: Transition back to implement with notes on what failed
"""
suggested_next = ["complete", "implement"]
on_blocked = "implement"

[[phases]]
id = "complete"
prompt = """
# Complete Phase

Finalize the implementation.

## Review CLAUDE.md Proposals

Proposals are auto-collected from implement phases. Check for pending proposals:

```bash
uv run ~/.claude-plugins/jons-plan/plan.py list-proposals
```

For each pending proposal, present to user via AskUserQuestion:
- Show: target file, proposed content, rationale
- Options: Accept, Reject
- If Accept: use Edit tool to apply the change to the target file
- Update status: `uv run ~/.claude-plugins/jons-plan/plan.py update-proposal-status <id> accepted|rejected`

## Review Challenges

Challenges are auto-collected from implement phases. Check for pending challenges:

```bash
uv run ~/.claude-plugins/jons-plan/plan.py list-challenges
```

For each pending challenge, present to user for acknowledgement:
- Show: title, what was attempted, what went wrong, workaround used
- No action needed - just acknowledge
- Update status: `uv run ~/.claude-plugins/jons-plan/plan.py acknowledge-challenge <id>`

## Final Tasks
1. Review all changes made
2. Ensure tests pass
3. Prepare commit message summarizing changes
4. Note any follow-up work needed

This is a terminal phase. The workflow is complete.
"""
terminal = true
