# Dynamic Workflow
# Research-first workflow where phases are generated based on codebase exploration

[workflow]
name = "dynamic"
description = "Research-first workflow - phases generated based on codebase exploration"

[[phases]]
id = "research-planning"
context_artifacts = ["research"]
required_artifacts = ["research-plan"]
prompt = """
# Research Planning Phase

Plan the research before diving in.

## Prior Research

If prior research findings are injected above (from a previous iteration), review them to identify what's already been answered. Focus the new research plan on unanswered questions only.

## Tasks

Identify what needs to be explored for this request:

1. **Project Structure** — Is this a monorepo? Frameworks? Where should changes go?
2. **Components Involved** — Frontend, backend, database, infrastructure?
3. **Domains and Concerns** — Security-sensitive? Migration? Performance?
4. **Dependencies** — Build order? Parallelization? Integration points?

## Outputs

Write `research-plan.md` with:
- Questions to answer (grouped by domain)
- Sources to consult
- Research task assignments
"""
suggested_next = ["research"]

[[phases]]
id = "research"
use_tasks = true
supports_prototypes = true
supports_cache_reference = true
context_artifacts = ["research-plan", "research"]
required_artifacts = ["research"]
prompt = """
# Research Phase

Execute the research plan (injected above).

If prior research findings are injected above (from a previous iteration), build on them — add new findings without removing existing content.

Explore the codebase and requirements. Document findings in `research.md` with sections for each area from the research plan.

If this is a subsequent iteration, append new findings to the existing research.md content.
"""
suggested_next = ["evaluate-research"]

[[phases]]
id = "evaluate-research"
max_retries = 4
context_artifacts = ["research-plan", "research"]
expand_prompt = """
Generate the workflow phases based on your research findings.

## Philosophy: Plan the Visible Horizon

Don't try to plan everything - plan what you can clearly see from research.

**Validation phases are checkpoints**, not just verification:
- Pause and verify progress
- Catch issues before they compound
- Decide: continue, or loop back to research?

Even for coupled components, break into chunks with validation between:
```
implement-auth-backend → validate-backend → implement-auth-frontend → validate-all
```

This creates natural re-planning points. If validate-backend reveals problems,
it can trigger a loopback to research rather than continuing blindly.

## When to Ask for User Input

If research revealed ambiguity or trade-offs, use AskUserQuestion before generating:
- Multiple valid structures (sequential vs parallel?)
- Optional phases (security review needed?)
- Scope decisions (include migration or separate plan?)

If research was clear, generate directly without asking.

## Guidelines

1. **One phase per logical chunk** - even coupled components benefit from checkpoints
2. **Validation after each implementation** - these are decision points
3. **Include loopback transitions** - validation phases should be able to return to research
4. **Security review** for auth/payment domains

## Verification Phases

Validation phases should specify how to verify:

**Prefer automated:**
- Test suite, type checker, linter, build
- API calls with curl/httpie
- Browser automation if MCP available

**If manual verification needed:**
- Set `requires_user_input: true` on the phase
- Phase prompt should instruct agent to generate precise testing procedure:
  1. Specific steps to perform
  2. Expected results for each step
  3. What constitutes pass/fail
- Agent waits for user to report results before continuing

## Phase Naming

- `plan-{component}`: Planning phase
- `implement-{component}`: Implementation phase
- `validate-{component}`: Checkpoint - verify before continuing
- `validate-all`: Final integration check

The `complete` phase already exists - point your final phase to it.
"""
prompt = """
# Evaluate Research Phase

Evaluate whether the research adequately answers the questions from the research plan.

## Process

1. Read the research plan (injected above) and list each question
2. Read the research findings (injected above)
3. For each question, assess: answered, partially answered, or unanswered

## Decision

- If all questions answered and work is **simple** (single component, clear changes): transition to **complete**
- If all questions answered and work is **complex** (multiple components, unclear dependencies): use **__expand__** to generate phases
- If significant gaps remain: transition to **research-planning** to plan additional research
"""
suggested_next = ["complete", "__expand__", "research-planning"]

[[phases]]
id = "complete"
terminal = true
suggested_next = [
    { phase = "research", requires_approval = true, approval_prompt = "Return to research phase for additional investigation?" }
]
prompt = """
# Complete Phase

Finalize the implementation.

## Review CLAUDE.md Proposals

Proposals are auto-collected from implement phases. Check for pending proposals:

```bash
uv run ~/.claude-plugins/jons-plan/plan.py list-proposals
```

For each pending proposal, present to user via AskUserQuestion:
- Show: target file, proposed content, rationale
- Options: Accept, Reject
- If Accept: use Edit tool to apply the change to the target file
- Update status: `uv run ~/.claude-plugins/jons-plan/plan.py update-proposal-status <id> accepted|rejected`

## Review Challenges

Challenges are auto-collected from implement phases. Check for pending challenges:

```bash
uv run ~/.claude-plugins/jons-plan/plan.py list-challenges
```

For each pending challenge, present to user for acknowledgement:
- Show: title, what was attempted, what went wrong, workaround used
- No action needed - just acknowledge
- Update status: `uv run ~/.claude-plugins/jons-plan/plan.py acknowledge-challenge <id>`

## Final Tasks

1. Review all changes made
2. Ensure tests pass
3. Prepare commit message summarizing changes
4. Note any follow-up work needed

This is a terminal phase. The workflow is complete.
"""
