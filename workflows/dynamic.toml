# Dynamic Workflow
# Research-first workflow where phases are generated based on codebase exploration

[workflow]
name = "dynamic"
description = "Research-first workflow - phases generated based on codebase exploration"

[[phases]]
id = "research-planning"
prompt_files = ["research-planning"]
context_artifacts = ["research"]
required_artifacts = ["research-plan"]
prompt = """
## Tasks

Identify what needs to be explored for this request:

1. **Project Structure** — Is this a monorepo? Frameworks? Where should changes go?
2. **Components Involved** — Frontend, backend, database, infrastructure?
3. **Domains and Concerns** — Security-sensitive? Migration? Performance?
4. **Dependencies** — Build order? Parallelization? Integration points?

## Outputs

Write `research-plan.md` with:
- Questions to answer (grouped by domain)
- Sources to consult
- Research task assignments
"""
suggested_next = [
    { phase = "research", instruction = "Research plan ready — begin research" }
]

[[phases]]
id = "research"
use_tasks = true
supports_prototypes = true
supports_cache_reference = true
context_artifacts = ["research-plan", "research"]
required_artifacts = ["research"]
prompt = """
# Research Phase

Execute the research plan (injected above).

If prior research findings are injected above (from a previous iteration), build on them — add new findings without removing existing content.

Explore the codebase and requirements. Document findings in `research.md` with sections for each area from the research plan.

If this is a subsequent iteration, append new findings to the existing research.md content.
"""
suggested_next = [
    { phase = "evaluate-research", instruction = "Research complete — evaluate findings" }
]

[[phases]]
id = "evaluate-research"
max_retries = 4
prompt_files = ["evaluate-research"]
context_artifacts = ["research-plan", "research"]
expand_prompt = """
Generate the workflow phases based on your research findings.

## Philosophy: Plan the Visible Horizon

Don't try to plan everything - plan what you can clearly see from research.

**Validation phases are checkpoints**, not just verification:
- Pause and verify progress
- Catch issues before they compound
- Decide: continue, or loop back to research?

Even for coupled components, break into chunks with validation between:
```
implement-auth-backend → validate-backend → implement-auth-frontend → validate-all
```

This creates natural re-planning points. If validate-backend reveals problems,
it can trigger a loopback to research rather than continuing blindly.

## When to Ask for User Input

If research revealed ambiguity or trade-offs, use AskUserQuestion before generating:
- Multiple valid structures (sequential vs parallel?)
- Optional phases (security review needed?)
- Scope decisions (include migration or separate plan?)

If research was clear, generate directly without asking.

## Guidelines

1. **One phase per logical chunk** - even coupled components benefit from checkpoints
2. **Validation after each implementation** - these are decision points
3. **Include loopback transitions** - validation phases should be able to return to research
4. **Security review** for auth/payment domains

## Verification Phases

Validation phases should specify how to verify:

**Prefer automated:**
- Test suite, type checker, linter, build
- API calls with curl/httpie
- Browser automation if MCP available

**If manual verification needed:**
- Set `requires_user_input: true` on the phase
- Phase prompt should instruct agent to generate precise testing procedure:
  1. Specific steps to perform
  2. Expected results for each step
  3. What constitutes pass/fail
- Agent waits for user to report results before continuing

## Phase Naming

- `plan-{component}`: Planning phase
- `implement-{component}`: Implementation phase
- `validate-{component}`: Checkpoint - verify before continuing
- `validate-all`: Final integration check

The `complete` phase already exists - point your final phase to it.
"""
suggested_next = [
    { phase = "complete", instruction = "All questions answered and work is simple (single component, clear changes)" },
    { phase = "__expand__", instruction = "All questions answered and work is complex (multiple components, unclear dependencies) — generate phases" },
    { phase = "research-planning", instruction = "Significant gaps remain — plan additional research for unanswered questions" }
]

[[phases]]
id = "complete"
terminal = true
prompt_files = ["proposals-and-challenges", "complete-implementation"]
suggested_next = [
    { phase = "research", instruction = "Return to research for additional investigation", requires_approval = true, approval_prompt = "Return to research phase for additional investigation?" }
]
